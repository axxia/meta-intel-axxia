From 175c0c3c2ee8aae7a1185f591988f02e0e3be103 Mon Sep 17 00:00:00 2001
From: Michael Jeanson <mjeanson@efficios.com>
Date: Tue, 11 Feb 2020 14:41:29 -0500
Subject: [PATCH 08/15] fix: KVM: x86: Use gpa_t for cr2/gpa to fix TDP support
 on 32-bit (v5.6)

See upstream commit :

  commit 736c291c9f36b07f8889c61764c28edce20e715d
  Author: Sean Christopherson <sean.j.christopherson@intel.com>
  Date:   Fri Dec 6 15:57:14 2019 -0800

    KVM: x86: Use gpa_t for cr2/gpa to fix TDP support on 32-bit KVM

    Convert a plethora of parameters and variables in the MMU and page fault
    flows from type gva_t to gpa_t to properly handle TDP on 32-bit KVM.

    Thanks to PSE and PAE paging, 32-bit kernels can access 64-bit physical
    addresses.  When TDP is enabled, the fault address is a guest physical
    address and thus can be a 64-bit value, even when both KVM and its guest
    are using 32-bit virtual addressing, e.g. VMX's VMCS.GUEST_PHYSICAL is a
    64-bit field, not a natural width field.

    Using a gva_t for the fault address means KVM will incorrectly drop the
    upper 32-bits of the GPA.  Ditto for gva_to_gpa() when it is used to
    translate L2 GPAs to L1 GPAs.

    Opportunistically rename variables and parameters to better reflect the
    dual address modes, e.g. use "cr2_or_gpa" for fault addresses and plain
    "addr" instead of "vaddr" when the address may be either a GVA or an L2
    GPA.  Similarly, use "gpa" in the nonpaging_page_fault() flows to avoid
    a confusing "gpa_t gva" declaration; this also sets the stage for a
    future patch to combing nonpaging_page_fault() and tdp_page_fault() with
    minimal churn.

    Sprinkle in a few comments to document flows where an address is known
    to be a GVA and thus can be safely truncated to a 32-bit value.  Add
    WARNs in kvm_handle_page_fault() and FNAME(gva_to_gpa_nested)() to help
    document such cases and detect bugs.

Signed-off-by: Michael Jeanson <mjeanson@efficios.com>
Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
---
 .../lttng-module/arch/x86/kvm/mmutrace.h      | 26 +++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/instrumentation/events/lttng-module/arch/x86/kvm/mmutrace.h b/instrumentation/events/lttng-module/arch/x86/kvm/mmutrace.h
index e25a7745..dd0c6798 100644
--- a/instrumentation/events/lttng-module/arch/x86/kvm/mmutrace.h
+++ b/instrumentation/events/lttng-module/arch/x86/kvm/mmutrace.h
@@ -214,6 +214,30 @@ LTTNG_TRACEPOINT_EVENT_MAP(
 	)
 )
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0) || \
+	LTTNG_KERNEL_RANGE(4,19,103, 4,20,0) || \
+	LTTNG_KERNEL_RANGE(5,4,19, 5,5,0) || \
+	LTTNG_KERNEL_RANGE(5,5,3, 5,6,0))
+LTTNG_TRACEPOINT_EVENT_MAP(
+	fast_page_fault,
+
+	kvm_mmu_fast_page_fault,
+
+	TP_PROTO(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u32 error_code,
+		 u64 *sptep, u64 old_spte, bool retry),
+	TP_ARGS(vcpu, cr2_or_gpa, error_code, sptep, old_spte, retry),
+
+	TP_FIELDS(
+		ctf_integer(int, vcpu_id, vcpu->vcpu_id)
+		ctf_integer(gpa_t, cr2_or_gpa, cr2_or_gpa)
+		ctf_integer(u32, error_code, error_code)
+		ctf_integer_hex(u64 *, sptep, sptep)
+		ctf_integer(u64, old_spte, old_spte)
+		ctf_integer(u64, new_spte, *sptep)
+		ctf_integer(bool, retry, retry)
+	)
+)
+#else
 LTTNG_TRACEPOINT_EVENT_MAP(
 	fast_page_fault,
 
@@ -233,6 +257,8 @@ LTTNG_TRACEPOINT_EVENT_MAP(
 		ctf_integer(bool, retry, retry)
 	)
 )
+#endif
+
 #endif /* LTTNG_TRACE_KVM_MMU_H */
 
 #undef TRACE_INCLUDE_PATH
-- 
2.17.1

