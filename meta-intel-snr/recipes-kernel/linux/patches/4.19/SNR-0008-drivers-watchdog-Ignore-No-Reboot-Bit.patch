From 391ce39664e8076ba4286b83b7d816e8aaf4c65e Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@intel.com>
Date: Wed, 29 May 2019 11:51:10 -0500
Subject: drivers/watchdog: Ignore 'No Reboot' Bit

Early versions of the SNR chip do not allow the "no reboot"
bit to be accessed.  This commit simply assumes that it is
writeable without checking in order to allow the watchdog to
but used in Linux.  This will be fixed in later versions of
the chip.

Signed-off-by: John Jacques <john.jacques@intel.com>
---
 drivers/watchdog/iTCO_wdt.c | 43 +++++++++++++++++++++++++++----------------
 1 file changed, 27 insertions(+), 16 deletions(-)

diff --git a/drivers/watchdog/iTCO_wdt.c b/drivers/watchdog/iTCO_wdt.c
index 347f038..b925f71 100644
--- a/drivers/watchdog/iTCO_wdt.c
+++ b/drivers/watchdog/iTCO_wdt.c
@@ -131,6 +131,11 @@ module_param(turn_SMI_watchdog_clear_off, int, 0);
 MODULE_PARM_DESC(turn_SMI_watchdog_clear_off,
 	"Turn off SMI clearing watchdog (depends on TCO-version)(default=1)");
 
+static int assume_noreboot_access = 0;
+module_param(assume_noreboot_access, int, 0);
+MODULE_PARM_DESC(assume_norebot_access,
+	"Assume that the No Reboot Bit is Accessible (Don't Check)");
+
 /*
  * Some TCO specific functions
  */
@@ -460,24 +465,30 @@ static int iTCO_wdt_probe(struct platform_device *pdev)
 	 * Get the Memory-Mapped GCS or PMC register, we need it for the
 	 * NO_REBOOT flag (TCO v2 and v3).
 	 */
-	if (p->iTCO_version >= 2 && !pdata->update_no_reboot_bit) {
-		p->gcs_pmc_res = platform_get_resource(pdev,
-						       IORESOURCE_MEM,
-						       ICH_RES_MEM_GCS_PMC);
-		p->gcs_pmc = devm_ioremap_resource(dev, p->gcs_pmc_res);
-		if (IS_ERR(p->gcs_pmc))
-			return PTR_ERR(p->gcs_pmc);
-	}
 
-	/* Check chipset's NO_REBOOT bit */
-	if (p->update_no_reboot_bit(p->no_reboot_priv, false) &&
-	    iTCO_vendor_check_noreboot_on()) {
-		pr_info("unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\n");
-		return -ENODEV;	/* Cannot reset NO_REBOOT bit */
-	}
+	if (assume_noreboot_access == 0) {
+		if (p->iTCO_version >= 2 && !pdata->update_no_reboot_bit) {
+			p->gcs_pmc_res = platform_get_resource(pdev,
+							       IORESOURCE_MEM,
+							       ICH_RES_MEM_GCS_PMC);
+			p->gcs_pmc = devm_ioremap_resource(dev, p->gcs_pmc_res);
+			if (IS_ERR(p->gcs_pmc))
+				return PTR_ERR(p->gcs_pmc);
+		}
+
+		/* Check chipset's NO_REBOOT bit */
+		if (p->update_no_reboot_bit(p->no_reboot_priv, false) &&
+		    iTCO_vendor_check_noreboot_on()) {
+			pr_info("unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\n");
+			return -ENODEV;	/* Cannot reset NO_REBOOT bit */
+		}
 
-	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
-	p->update_no_reboot_bit(p->no_reboot_priv, true);
+		/*
+		 * Set the NO_REBOOT bit to prevent later reboots,
+		 * just for sure
+		 */
+		p->update_no_reboot_bit(p->no_reboot_priv, true);
+	}
 
 	/* The TCO logic uses the TCO_EN bit in the SMI_EN register */
 	if (!devm_request_region(dev, p->smi_res->start,
-- 
2.7.4

