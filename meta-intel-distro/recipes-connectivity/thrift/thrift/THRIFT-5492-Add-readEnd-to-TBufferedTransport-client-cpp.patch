From 43801aac04f57ddcf0d7eb86eed9d1277dd8bc2f Mon Sep 17 00:00:00 2001
From: Steve Licking <steve.licking@intel.com>
Date: Fri, 31 Dec 2021 10:54:05 -0800
Subject: [PATCH] THRIFT-5492: Add readEnd to TBufferedTransport client: cpp

Add a readEnd implementation to TBufferedTransport which resets the consumed
message size.  Without this it was noticed that calls to the transport's
consume method would slowly decrement the remainingMessageSize_ and the
remainingMessageSize_ was never reset.  A client could send many messages to
the server, eventually bringing remainingMessageSize_ below zero causing an
EOD_OF_FILE exception.
---
 .../src/thrift/transport/TBufferTransports.h  |  5 ++
 test/StressTest.thrift                        |  1 +
 test/cpp/src/StressTest.cpp                   | 60 ++++++++++++++-----
 test/cpp/src/StressTestNonBlocking.cpp        |  3 +
 4 files changed, 54 insertions(+), 15 deletions(-)

diff --git a/lib/cpp/src/thrift/transport/TBufferTransports.h b/lib/cpp/src/thrift/transport/TBufferTransports.h
index 3ef8d1f6aca..8278d5c685a 100644
--- a/lib/cpp/src/thrift/transport/TBufferTransports.h
+++ b/lib/cpp/src/thrift/transport/TBufferTransports.h
@@ -270,6 +270,11 @@ class TBufferedTransport : public TVirtualTransport<TBufferedTransport, TBufferB
    */
   uint32_t readAll(uint8_t* buf, uint32_t len) { return TBufferBase::readAll(buf, len); }
 
+  uint32_t readEnd() override {
+    resetConsumedMessageSize();
+    return 0;
+  }
+
 protected:
   void initPointers() {
     setReadBuffer(rBuf_.get(), 0);
diff --git a/test/StressTest.thrift b/test/StressTest.thrift
index 431811b87a7..2dfecd1fe82 100644
--- a/test/StressTest.thrift
+++ b/test/StressTest.thrift
@@ -31,5 +31,6 @@ service Service {
   list<i8>  echoList(1: list<i8> arg),
   set<i8>  echoSet(1: set<i8> arg),
   map<i8, i8>  echoMap(1: map<i8, i8> arg),
+  binary echoBinary(1: binary arg),
 }
 
diff --git a/test/cpp/src/StressTest.cpp b/test/cpp/src/StressTest.cpp
index 79a708e8f57..3c0ddbfd100 100644
--- a/test/cpp/src/StressTest.cpp
+++ b/test/cpp/src/StressTest.cpp
@@ -95,6 +95,9 @@ class Server : public ServiceIf {
   void echoList(vector<int8_t>& out, const vector<int8_t>& arg) override { out = arg; }
   void echoSet(set<int8_t>& out, const set<int8_t>& arg) override { out = arg; }
   void echoMap(map<int8_t, int8_t>& out, const map<int8_t, int8_t>& arg) override { out = arg; }
+  void echoBinary(string& out, const string& arg) override {
+    out = arg;
+  }
 
 private:
   count_map counts_;
@@ -105,6 +108,14 @@ enum TransportOpenCloseBehavior {
   OpenAndCloseTransportInThread,
   DontOpenAndCloseTransportInThread
 };
+enum TestLoopType {
+  TestLoopVoid,
+  TestLoopByte,
+  TestLoopI32,
+  TestLoopI64,
+  TestLoopString,
+  TestLoopBinary
+};
 class ClientThread : public Runnable {
 public:
   ClientThread(std::shared_ptr<TTransport> transport,
@@ -112,7 +123,7 @@ class ClientThread : public Runnable {
                Monitor& monitor,
                size_t& workerCount,
                size_t loopCount,
-               TType loopType,
+               TestLoopType loopType,
                TransportOpenCloseBehavior behavior)
     : _transport(transport),
       _client(client),
@@ -139,21 +150,24 @@ class ClientThread : public Runnable {
     }
 
     switch (_loopType) {
-    case T_VOID:
+    case TestLoopVoid:
       loopEchoVoid();
       break;
-    case T_BYTE:
+    case TestLoopByte:
       loopEchoByte();
       break;
-    case T_I32:
+    case TestLoopI32:
       loopEchoI32();
       break;
-    case T_I64:
+    case TestLoopI64:
       loopEchoI64();
       break;
-    case T_STRING:
+    case TestLoopString:
       loopEchoString();
       break;
+    case TestLoopBinary:
+      loopEchoBinary();
+      break;
     default:
       cerr << "Unexpected loop type" << _loopType << endl;
       break;
@@ -224,12 +238,26 @@ class ClientThread : public Runnable {
     }
   }
 
+  void loopEchoBinary() {
+    /* fillSize, the length of the binary data transfered, is kept small to
+     * ensure that TBinaryProtocol's readString can call TBufferTransport's
+     * borrow and NOT fall into the borrowSlow path. */
+    size_t fillSize = 410;
+    char fillData = '!';
+    string arg(fillSize, fillData);
+    for (size_t ix = 0; ix < _loopCount; ix++) {
+      string result;
+      _client->echoBinary(result, arg);
+      assert(result == arg);
+    }
+  }
+
   std::shared_ptr<TTransport> _transport;
   std::shared_ptr<ServiceIf> _client;
   Monitor& _monitor;
   size_t& _workerCount;
   size_t _loopCount;
-  TType _loopType;
+  TestLoopType _loopType;
   int64_t _startTime;
   int64_t _endTime;
   bool _done;
@@ -267,9 +295,9 @@ int main(int argc, char** argv) {
   string protocolType = "binary";
   size_t workerCount = 8;
   size_t clientCount = 4;
-  size_t loopCount = 50000;
-  TType loopType = T_VOID;
-  string callName = "echoVoid";
+  size_t loopCount = 256000;
+  TestLoopType loopType = TestLoopBinary;
+  string callName = "echoBinary";
   bool runServer = true;
   bool logRequests = false;
   string requestLogPath = "./requestlog.tlog";
@@ -488,15 +516,17 @@ int main(int argc, char** argv) {
     set<std::shared_ptr<Thread> > clientThreads;
 
     if (callName == "echoVoid") {
-      loopType = T_VOID;
+      loopType = TestLoopVoid;
     } else if (callName == "echoByte") {
-      loopType = T_BYTE;
+      loopType = TestLoopByte;
     } else if (callName == "echoI32") {
-      loopType = T_I32;
+      loopType = TestLoopI32;
     } else if (callName == "echoI64") {
-      loopType = T_I64;
+      loopType = TestLoopI64;
     } else if (callName == "echoString") {
-      loopType = T_STRING;
+      loopType = TestLoopString;
+    } else if (callName == "echoBinary") {
+      loopType = TestLoopBinary;
     } else {
       throw invalid_argument("Unknown service call " + callName);
     }
diff --git a/test/cpp/src/StressTestNonBlocking.cpp b/test/cpp/src/StressTestNonBlocking.cpp
index e94ecb2db11..c0430067baf 100644
--- a/test/cpp/src/StressTestNonBlocking.cpp
+++ b/test/cpp/src/StressTestNonBlocking.cpp
@@ -99,6 +99,9 @@ class Server : public ServiceIf {
   void echoList(vector<int8_t>& out, const vector<int8_t>& arg) override { out = arg; }
   void echoSet(set<int8_t>& out, const set<int8_t>& arg) override { out = arg; }
   void echoMap(map<int8_t, int8_t>& out, const map<int8_t, int8_t>& arg) override { out = arg; }
+  void echoBinary(string& out, const string& arg) override {
+    out = arg;
+  }
 
 private:
   count_map counts_;
